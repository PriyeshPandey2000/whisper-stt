import type { NoteFluxError } from '$lib/result';
import type { ClipboardServiceError } from '$lib/services/clipboard';

import { WHISPERING_RECORDINGS_PATHNAME } from '$lib/constants/app';
import { settings } from '$lib/stores/settings.svelte';
import { Ok } from 'wellcrafted/result';

import { defineMutation } from './_client';
import { rpc } from './index';

export const delivery = {
	/**
	 * Delivers transcribed text to the user according to their clipboard preferences.
	 *
	 * This mutation handles the complete delivery workflow for transcription results:
	 * 1. Shows a success toast with the transcribed text
	 * 2. Optionally copies text to clipboard based on user settings
	 * 3. Optionally pastes text at cursor based on user settings
	 * 4. Provides fallback UI actions when automatic operations fail
	 *
	 * The user's preferences are read from:
	 * - `transcription.clipboard.copyOnSuccess` - Whether to auto-copy
	 * - `transcription.clipboard.pasteOnSuccess` - Whether to auto-paste
	 *
	 * @param text - The transcribed text to deliver
	 * @param toastId - Unique ID for toast notifications to prevent duplicates
	 * @returns Result with no meaningful data (fire-and-forget operation)
	 *
	 * @example
	 * ```typescript
	 * // After transcription completes
	 * await rpc.delivery.deliverTranscriptionResult.execute({
	 *   text: transcribedText,
	 *   toastId: nanoid()
	 * });
	 * ```
	 */
	deliverTranscriptionResult: defineMutation({
		mutationKey: ['delivery', 'deliverTranscriptionResult'],
		resultMutationFn: async ({
			text,
			toastId,
			initiatedVia = 'local',
		}: {
			text: string;
			toastId: string;
			initiatedVia?: 'global-shortcut' | 'local';
		}) => {
			// Shows transcription result and offers manual copy action
			const offerManualCopy = () =>
				rpc.notify.success.execute({
					title: 'üìù Recording transcribed!',
					description: text,
					action: {
						label: 'Copy to clipboard',
						onClick: async () => {
							const { error } = await rpc.clipboard.copyToClipboard.execute({
								text,
							});
							if (error) {
								// Report that manual copy attempt failed
								rpc.notify.error.execute({
									title: 'Error copying transcribed text to clipboard',
									description: error.message,
									action: { error, type: 'more-details' },
								});
								return;
							}
							// Confirm manual copy succeeded
							rpc.notify.success.execute({
								title: 'Copied transcribed text to clipboard!',
								description: text,
								id: toastId,
							});
						},
						type: 'button',
					},
					id: toastId,
				});

			// Warns that automatic copy failed and falls back to manual option
			const warnAutoCopyFailed = (error: ClipboardServiceError) => {
				rpc.notify.warning.execute({
					title: "Couldn't copy to clipboard",
					description: error.message,
					action: { error, type: 'more-details' },
				});
			};

			// Confirms text is in clipboard (when paste is not attempted)
			const confirmTextInClipboard = () =>
				rpc.notify.success.execute({
					title: 'üìù Recording transcribed and copied to clipboard!',
					description: text,
					action: {
						href: WHISPERING_RECORDINGS_PATHNAME,
						label: 'Go to recordings',
						type: 'link',
					},
					id: toastId,
				});

			// Warns that paste failed but confirms copy succeeded
			const warnPasteFailedButCopied = (
				error: ClipboardServiceError | NoteFluxError,
			) => {
				if (error.name === 'ClipboardServiceError') {
					rpc.notify.warning.execute({
						title: 'Unable to paste automatically',
						description: error.message,
						action: { error, type: 'more-details' },
					});
					return;
				}
				if (error.name === 'NoteFluxError') {
					rpc.notify[error.severity].execute(error);
					return;
				}
			};

			// Confirms complete delivery (both copy and paste succeeded)
			const confirmFullDelivery = () =>
				rpc.notify.success.execute({
					title: 'üìù Recording transcribed, copied to clipboard, and pasted!',
					description: text,
					action: {
						href: WHISPERING_RECORDINGS_PATHNAME,
						label: 'Go to recordings',
						type: 'link',
					},
					id: toastId,
				});

			// Main delivery flow

			// If user doesn't want auto-copy, just show the result with manual option
			if (!settings.value['transcription.clipboard.copyOnSuccess']) {
				offerManualCopy();
				return Ok(undefined);
			}

			// Try to copy to clipboard
			const { error: copyError } = await rpc.clipboard.copyToClipboard.execute({
				text,
			});
			if (copyError) {
				warnAutoCopyFailed(copyError);
				offerManualCopy();
				return Ok(undefined);
			}

			// If user doesn't want auto-paste, confirm copy only
			if (!settings.value['transcription.clipboard.pasteOnSuccess']) {
				confirmTextInClipboard();
				return Ok(undefined);
			}

			// Try to paste at cursor - use different methods based on how recording was initiated
			console.log('üéØ [DELIVERY] Starting paste operation, initiatedVia:', initiatedVia);

			// No delay needed since we use notifications instead of overlays

			let pasteError: ClipboardServiceError | NoteFluxError | null | undefined;
			if (initiatedVia === 'global-shortcut') {
				console.log('‚å®Ô∏è [DELIVERY] Using typeAtCursor for global shortcut');
				// For global shortcuts, type directly at cursor position to ensure it works
				// regardless of focus changes during recording

				// Check if we're pasting into the app itself (e.g., during onboarding)
				// If so, keep the window visible instead of hiding it
				const activeElement = document.activeElement;
				const isPastingIntoApp = activeElement &&
					(activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT');

				console.log('üìç [DELIVERY] Active element:', activeElement?.tagName, 'isPastingIntoApp:', isPastingIntoApp);

				if (isPastingIntoApp) {
					console.log('üìù [DELIVERY] Pasting into app using direct DOM insertion');
					try {
						const element = activeElement as HTMLTextAreaElement | HTMLInputElement;
						const start = element.selectionStart || 0;
						const end = element.selectionEnd || 0;
						const currentValue = element.value;
						element.value = currentValue.slice(0, start) + text + currentValue.slice(end);
						const newCursorPos = start + text.length;
						element.selectionStart = newCursorPos;
						element.selectionEnd = newCursorPos;
						element.dispatchEvent(new Event('input'));
						console.log('‚úÖ [DELIVERY] Direct DOM insertion succeeded');
						pasteError = undefined;
					} catch (error) {
						console.error('‚ùå [DELIVERY] Direct DOM insertion failed:', error);
						pasteError = ClipboardServiceErr({ message: 'Failed to paste into text field', cause: error }).error;
					}
				} else {
					const { error } = await rpc.clipboard.typeAtCursor.execute({
						text,
						keepWindowVisible: false
					});
					pasteError = error;
					if (pasteError) {
						console.error('‚ùå [DELIVERY] typeAtCursor failed:', pasteError);
					} else {
						console.log('‚úÖ [DELIVERY] typeAtCursor succeeded');
					}
				}
			} else {
				console.log('üìã [DELIVERY] Using pasteFromClipboard for local action');
				// For local shortcuts, use standard paste (Cmd+V/Ctrl+V)
				const { error } = await rpc.clipboard.pasteFromClipboard.execute(undefined);
				pasteError = error;
				if (pasteError) {
					console.error('‚ùå [DELIVERY] pasteFromClipboard failed:', pasteError);
				} else {
					console.log('‚úÖ [DELIVERY] pasteFromClipboard succeeded');
				}
			}

			if (pasteError) {
				warnPasteFailedButCopied(pasteError);
				confirmTextInClipboard();
				return Ok(undefined);
			}

			// Everything succeeded
			confirmFullDelivery();
			return Ok(undefined);
		},
	}),

	/**
	 * Delivers transformed text to the user according to their clipboard preferences.
	 *
	 * This mutation handles the complete delivery workflow for transformation results:
	 * 1. Shows a success toast with the transformed text
	 * 2. Optionally copies text to clipboard based on user settings
	 * 3. Optionally pastes text at cursor based on user settings
	 * 4. Provides fallback UI actions when automatic operations fail
	 *
	 * The user's preferences are read from:
	 * - `transformation.clipboard.copyOnSuccess` - Whether to auto-copy
	 * - `transformation.clipboard.pasteOnSuccess` - Whether to auto-paste
	 *
	 * @param text - The transformed text to deliver
	 * @param toastId - Unique ID for toast notifications to prevent duplicates
	 * @returns Result with no meaningful data (fire-and-forget operation)
	 *
	 * @example
	 * ```typescript
	 * // After transformation completes
	 * await rpc.delivery.deliverTransformationResult.execute({
	 *   text: transformedText,
	 *   toastId: nanoid()
	 * });
	 * ```
	 */
	deliverTransformationResult: defineMutation({
		mutationKey: ['delivery', 'deliverTransformationResult'],
		resultMutationFn: async ({
			text,
			toastId,
			initiatedVia = 'local',
		}: {
			text: string;
			toastId: string;
			initiatedVia?: 'global-shortcut' | 'local';
		}) => {
			// Define all notification functions at the top for clarity

			// Shows transformation result and offers manual copy action
			const offerManualCopy = () =>
				rpc.notify.success.execute({
					title: 'üîÑ Transformation complete!',
					description: text,
					action: {
						label: 'Copy to clipboard',
						onClick: async () => {
							const { error } = await rpc.clipboard.copyToClipboard.execute({
								text,
							});
							if (error) {
								// Report that manual copy attempt failed
								rpc.notify.error.execute({
									title: 'Error copying transformed text to clipboard',
									description: error.message,
									action: { error, type: 'more-details' },
								});
								return;
							}
							// Confirm manual copy succeeded
							rpc.notify.success.execute({
								title: 'Copied transformed text to clipboard!',
								description: text,
								id: toastId,
							});
						},
						type: 'button',
					},
					id: toastId,
				});

			// Warns that automatic copy failed and falls back to manual option
			const warnAutoCopyFailed = (error: ClipboardServiceError) => {
				rpc.notify.warning.execute({
					title: "Couldn't copy to clipboard",
					description: error.message,
					action: { error, type: 'more-details' },
				});
			};

			// Confirms text is in clipboard (when paste is not attempted)
			const confirmTextInClipboard = () =>
				rpc.notify.success.execute({
					title: 'üîÑ Transformation complete and copied to clipboard!',
					description: text,
					action: {
						href: WHISPERING_RECORDINGS_PATHNAME,
						label: 'Go to recordings',
						type: 'link',
					},
					id: toastId,
				});

			// Warns that paste failed but confirms copy succeeded
			const warnPasteFailedButCopied = (
				error: ClipboardServiceError | NoteFluxError,
			) => {
				if (error.name === 'ClipboardServiceError') {
					rpc.notify.error.execute({
						title: 'Error pasting transformed text to cursor',
						description: error.message,
						action: { error, type: 'more-details' },
					});
					return;
				}
				if (error.name === 'NoteFluxError') {
					rpc.notify[error.severity].execute(error);
					return;
				}
			};

			// Confirms complete delivery (both copy and paste succeeded)
			const confirmFullDelivery = () =>
				rpc.notify.success.execute({
					title: 'üîÑ Transformation complete, copied to clipboard, and pasted!',
					description: text,
					action: {
						href: WHISPERING_RECORDINGS_PATHNAME,
						label: 'Go to recordings',
						type: 'link',
					},
					id: toastId,
				});

			// Main delivery flow

			// If user doesn't want auto-copy, just show the result with manual option
			if (!settings.value['transformation.clipboard.copyOnSuccess']) {
				offerManualCopy();
				return Ok(undefined);
			}

			// Try to copy to clipboard
			const { error: copyError } = await rpc.clipboard.copyToClipboard.execute({
				text,
			});
			if (copyError) {
				warnAutoCopyFailed(copyError);
				offerManualCopy();
				return Ok(undefined);
			}

			// If user doesn't want auto-paste, confirm copy only
			if (!settings.value['transformation.clipboard.pasteOnSuccess']) {
				confirmTextInClipboard();
				return Ok(undefined);
			}

			// Try to paste at cursor - use different methods based on how recording was initiated
			console.log('üéØ [DELIVERY] Starting paste operation, initiatedVia:', initiatedVia);

			// No delay needed since we use notifications instead of overlays

			let pasteError: ClipboardServiceError | NoteFluxError | null | undefined;
			if (initiatedVia === 'global-shortcut') {
				console.log('‚å®Ô∏è [DELIVERY] Using typeAtCursor for global shortcut');
				// For global shortcuts, type directly at cursor position to ensure it works
				// regardless of focus changes during recording

				// Check if we're pasting into the app itself (e.g., during onboarding)
				// If so, keep the window visible instead of hiding it
				const activeElement = document.activeElement;
				const isPastingIntoApp = activeElement &&
					(activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT');

				console.log('üìç [DELIVERY] Active element:', activeElement?.tagName, 'isPastingIntoApp:', isPastingIntoApp);

				if (isPastingIntoApp) {
					console.log('üìù [DELIVERY] Pasting into app using direct DOM insertion');
					try {
						const element = activeElement as HTMLTextAreaElement | HTMLInputElement;
						const start = element.selectionStart || 0;
						const end = element.selectionEnd || 0;
						const currentValue = element.value;
						element.value = currentValue.slice(0, start) + text + currentValue.slice(end);
						const newCursorPos = start + text.length;
						element.selectionStart = newCursorPos;
						element.selectionEnd = newCursorPos;
						element.dispatchEvent(new Event('input'));
						console.log('‚úÖ [DELIVERY] Direct DOM insertion succeeded');
						pasteError = undefined;
					} catch (error) {
						console.error('‚ùå [DELIVERY] Direct DOM insertion failed:', error);
						pasteError = ClipboardServiceErr({ message: 'Failed to paste into text field', cause: error }).error;
					}
				} else {
					const { error } = await rpc.clipboard.typeAtCursor.execute({
						text,
						keepWindowVisible: false
					});
					pasteError = error;
					if (pasteError) {
						console.error('‚ùå [DELIVERY] typeAtCursor failed:', pasteError);
					} else {
						console.log('‚úÖ [DELIVERY] typeAtCursor succeeded');
					}
				}
			} else {
				console.log('üìã [DELIVERY] Using pasteFromClipboard for local action');
				// For local shortcuts, use standard paste (Cmd+V/Ctrl+V)
				const { error } = await rpc.clipboard.pasteFromClipboard.execute(undefined);
				pasteError = error;
				if (pasteError) {
					console.error('‚ùå [DELIVERY] pasteFromClipboard failed:', pasteError);
				} else {
					console.log('‚úÖ [DELIVERY] pasteFromClipboard succeeded');
				}
			}

			if (pasteError) {
				warnPasteFailedButCopied(pasteError);
				confirmTextInClipboard();
				return Ok(undefined);
			}

			// Everything succeeded
			confirmFullDelivery();
			return Ok(undefined);
		},
	}),
};
